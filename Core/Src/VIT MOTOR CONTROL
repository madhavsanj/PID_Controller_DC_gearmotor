#include "stm32f411xe.h"
#include <stdint.h>

/* ================= USER SETTINGS ================= */
#define TARGET_RPM      200.0f       // legacy target, now overridden by pot
#define CPR             4800.0f      // calibrated counts per rev
#define Ts              0.05f        // 50 ms sample time (was 0.10f)

/* PID gains */
#define KP  1.5f         // was 1.3f
#define KI  0.60f        // was 0.20f
#define KD  0.02f        // was 0.05f

/* Integral windup limits */
#define I_MAX   400.0f
#define I_MIN  -400.0f

#define PWM_MAX  999.0f
#define PWM_MIN  0.0f
#define BASE_PWM 350.0f


/* ================= DELAY ================= */
static void delay(volatile uint32_t t)
{
    while (t--) __NOP();
}

/* ================= UART ================= */
static void uart_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    GPIOA->MODER &= ~((3U<<(2*2))|(3U<<(3*2)));
    GPIOA->MODER |=  ((2U<<(2*2))|(2U<<(3*2)));

    GPIOA->AFR[0] &= ~((0xFU<<(2*4))|(0xFU<<(3*4)));
    GPIOA->AFR[0] |=  ((7U<<(2*4))|(7U<<(3*4)));

    USART2->BRR = 0x008B;
    USART2->CR1 = USART_CR1_TE | USART_CR1_UE;
}

static void uart_send(char c)
{
    while (!(USART2->SR & USART_SR_TXE));
    USART2->DR = c;
}

static void uart_print(const char *s)
{
    while (*s) uart_send(*s++);
}

static void uart_print_num(int32_t n)
{
    char buf[16];
    int i = 0;

    if (n == 0) { uart_send('0'); return; }
    if (n < 0) { uart_send('-'); n = -n; }

    while (n > 0) { buf[i++] = (n % 10) + '0'; n /= 10; }
    while (i--) uart_send(buf[i]);
}

/* ================= ADC: PA4 ================= */
static void adc_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

    GPIOA->MODER |= (3U << (4 * 2)); // PA4 analog mode

    ADC1->CR2 = ADC_CR2_ADON; // Enable ADC
}

static uint16_t adc_read(void)
{
    ADC1->SQR3 = 4; // Channel 4 (PA4)
    ADC1->CR2 |= ADC_CR2_SWSTART;
    while (!(ADC1->SR & ADC_SR_EOC));
    return (uint16_t)ADC1->DR;
}

/* ================= MOTOR DIR ================= */
static void motor_dir_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
    GPIOB->MODER &= ~((3U<<(0*2))|(3U<<(1*2)));
    GPIOB->MODER |=  ((1U<<(0*2))|(1U<<(1*2)));
}

static void motor_forward(void)
{
    GPIOB->ODR |=  (1U << 0);
    GPIOB->ODR &= ~(1U << 1);
}

/* ================= PWM: TIM1 CH1 ================= */
static void pwm_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

    GPIOA->MODER &= ~(3U<<(8*2));
    GPIOA->MODER |=  (2U<<(8*2));
    GPIOA->AFR[1] &= ~(0xFU<<0);
    GPIOA->AFR[1] |=  (1U<<0);

    TIM1->PSC = 15;   // 1 MHz clock
    TIM1->ARR = 999;  // 1 kHz PWM
    TIM1->CCMR1 = (6U<<4);
    TIM1->CCER  = TIM_CCER_CC1E;
    TIM1->BDTR  = TIM_BDTR_MOE;
    TIM1->CR1   = TIM_CR1_CEN;
}

static void set_pwm(float duty)
{
    if (duty > PWM_MAX) duty = PWM_MAX;
    if (duty < PWM_MIN) duty = PWM_MIN;
    TIM1->CCR1 = (uint16_t)duty;
}

/* ================= ENCODER: TIM2 ================= */
static void encoder_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    GPIOA->MODER &= ~((3U<<(0*2))|(3U<<(1*2)));
    GPIOA->MODER |=  ((2U<<(0*2))|(2U<<(1*2)));
    GPIOA->AFR[0] &= ~((0xFU<<(0*4))|(0xFU<<(1*4)));
    GPIOA->AFR[0] |=  ((1U<<(0*4))|(1U<<(1*4)));

    TIM2->SMCR  = TIM_SMCR_SMS_0 | TIM_SMCR_SMS_1;
    TIM2->CCMR1 = TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
    TIM2->CCER  = TIM_CCER_CC1E | TIM_CCER_CC2E;

    TIM2->ARR = 0xFFFF;
    TIM2->CNT = 0;
    TIM2->CR1 |= TIM_CR1_CEN;
}

/* ================= MAIN ================= */
int main(void)
{
    uart_init();
    adc_init();
    pwm_init();
    motor_dir_init();
    encoder_init();

    motor_forward();
    uart_print("\r\n=== PID + POT SPEED CTRL (Ts=50ms) ===\r\n");

    int32_t last_cnt = 0;

    /* PID state */
    float integral = 0.0f;
    float last_rpm = 0.0f;
    float pwm = BASE_PWM;

    set_pwm(pwm);

    while (1)
    {
        /* 50 ms instead of 100 ms */
        delay(800000);

        /* --- Read ADC → target RPM (0–300) --- */
        uint16_t adc_raw = adc_read();
        float target_rpm = (adc_raw / 4095.0f) * 300.0f;

        /* --- Encoder RPM --- */
        int32_t now = TIM2->CNT;
        int32_t diff = now - last_cnt;

        if (diff > 32767) diff -= 65536;
        else if (diff < -32768) diff += 65536;

        last_cnt = now;

        float rpm = (float)diff * 600.0f / CPR;
        if (rpm < 0) rpm = -rpm;

        /* --- PID ERROR --- */
        float error = target_rpm - rpm;

        /* INTEGRAL */
        integral += (error * KI * Ts);
        if (integral > I_MAX) integral = I_MAX;
        if (integral < I_MIN) integral = I_MIN;

        /* DERIVATIVE */
        float derivative = (rpm - last_rpm) / Ts;

        /* PID output */
        float u = BASE_PWM
                  + KP * error
                  + integral
                  - KD * derivative;

        pwm = u;

        /* Anti-stall: if commanded speed is non-trivial and rpm is near 0,
           give it a kick so encoder starts counting */
        if (rpm < 10.0f && target_rpm > 30.0f) {
            pwm = 800.0f;
        }

        set_pwm(pwm);
        last_rpm = rpm;

        /* PRINT: ADC, TargetRPM, MeasuredRPM */
        uart_print_num(adc_raw);
        uart_print(",");
        uart_print_num((int32_t)target_rpm);
        uart_print(",");
        uart_print_num((int32_t)rpm);
        uart_print("\r\n");
    }
}
