#include "stm32f411xe.h"
#include <stdint.h>

/* ================= USER SETTINGS ================= */
#define TARGET_RPM      200.0f       // target speed
#define CPR             4800.0f      // calibrated counts per rev
#define Ts              0.10f        // 100 ms sample time

/* PID gains */
#define KP  1.3f
#define KI  0.20f      // integral per second (scaled by Ts)
#define KD  0.05f      // derivative per second

/* Integral windup limits */
#define I_MAX   400.0f
#define I_MIN  -400.0f

#define PWM_MAX  999.0f
#define PWM_MIN  0.0f
#define BASE_PWM 350.0f


/* ================= DELAY ================= */
static void delay(volatile uint32_t t)
{
    while (t--) __NOP();
}

/* ================= UART ================= */
static void uart_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    GPIOA->MODER &= ~((3U<<(2*2))|(3U<<(3*2)));
    GPIOA->MODER |=  ((2U<<(2*2))|(2U<<(3*2)));

    GPIOA->AFR[0] &= ~((0xFU<<(2*4))|(0xFU<<(3*4)));
    GPIOA->AFR[0] |=  ((7U<<(2*4))|(7U<<(3*4)));

    USART2->BRR = 0x008B;
    USART2->CR1 = USART_CR1_TE | USART_CR1_UE;
}

static void uart_send(char c)
{
    while (!(USART2->SR & USART_SR_TXE));
    USART2->DR = c;
}

static void uart_print(const char *s)
{
    while (*s) uart_send(*s++);
}

static void uart_print_num(int32_t n)
{
    char buf[16];
    int i = 0;

    if (n == 0) { uart_send('0'); return; }
    if (n < 0) { uart_send('-'); n = -n; }

    while (n > 0) { buf[i++] = (n % 10) + '0'; n /= 10; }
    while (i--) uart_send(buf[i]);
}

/* ================= MOTOR DIR ================= */
static void motor_dir_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
    GPIOB->MODER &= ~((3U<<(0*2))|(3U<<(1*2)));
    GPIOB->MODER |=  ((1U<<(0*2))|(1U<<(1*2)));
}

static void motor_forward(void)
{
    GPIOB->ODR |=  (1U << 0);
    GPIOB->ODR &= ~(1U << 1);
}

/* ================= PWM: TIM1 CH1 ================= */
static void pwm_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

    GPIOA->MODER &= ~(3U<<(8*2));
    GPIOA->MODER |=  (2U<<(8*2));
    GPIOA->AFR[1] &= ~(0xFU<<0);
    GPIOA->AFR[1] |=  (1U<<0);

    TIM1->PSC = 15;   // 1 MHz clock
    TIM1->ARR = 999;  // 1 kHz PWM
    TIM1->CCMR1 = (6U<<4);
    TIM1->CCER  = TIM_CCER_CC1E;
    TIM1->BDTR  = TIM_BDTR_MOE;
    TIM1->CR1   = TIM_CR1_CEN;
}

static void set_pwm(float duty)
{
    if (duty > PWM_MAX) duty = PWM_MAX;
    if (duty < PWM_MIN) duty = PWM_MIN;
    TIM1->CCR1 = (uint16_t)duty;
}

/* ================= ENCODER: TIM2 ================= */
static void encoder_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    GPIOA->MODER &= ~((3U<<(0*2))|(3U<<(1*2)));
    GPIOA->MODER |=  ((2U<<(0*2))|(2U<<(1*2)));
    GPIOA->AFR[0] &= ~((0xFU<<(0*4))|(0xFU<<(1*4)));
    GPIOA->AFR[0] |=  ((1U<<(0*4))|(1U<<(1*4)));

    TIM2->SMCR  = TIM_SMCR_SMS_0 | TIM_SMCR_SMS_1;
    TIM2->CCMR1 = TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
    TIM2->CCER  = TIM_CCER_CC1E | TIM_CCER_CC2E;

    TIM2->ARR = 0xFFFF;
    TIM2->CNT = 0;
    TIM2->CR1 |= TIM_CR1_CEN;
}

/* ================= MAIN ================= */
int main(void)
{
    uart_init();
    pwm_init();
    motor_dir_init();
    encoder_init();

    motor_forward();
    uart_print("\r\n=== FULL PID CLOSED-LOOP (CPR=4800) ===\r\n");

    int32_t last_cnt = 0;

    /* PID state */
    float integral = 0.0f;
    float last_rpm = 0.0f;
    float pwm = BASE_PWM;

    set_pwm(pwm);

    while (1)
    {
        delay(1600000);   // 100 ms

        int32_t now = TIM2->CNT;
        int32_t diff = now - last_cnt;

        if (diff > 32767) diff -= 65536;
        else if (diff < -32768) diff += 65536;

        last_cnt = now;

        /* RPM calculation */
        float rpm = (float)diff * 600.0f / CPR;
        if (rpm < 0) rpm = -rpm;

        /* PID ERROR */
        float error = TARGET_RPM - rpm;

        /* --- INTEGRAL (with dt) --- */
        integral += (error * KI * Ts);
        if (integral > I_MAX) integral = I_MAX;
        if (integral < I_MIN) integral = I_MIN;

        /* --- DERIVATIVE (with dt) --- */
        float derivative = (rpm - last_rpm) / Ts;

        /* --- PID OUTPUT --- */
        float u = BASE_PWM
                  + KP * error
                  + integral
                  - KD * derivative;

        pwm = u;
        set_pwm(pwm);

        last_rpm = rpm;

        /* DEBUG PRINT */
        //uart_print("RPM: ");
        uart_print_num((int32_t)rpm);
        uart_print(",");
        uart_print_num((int32_t)pwm);
        uart_print("\r\n");
    }
}
