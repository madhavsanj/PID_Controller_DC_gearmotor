#include "stm32f411xe.h"
#include <stdint.h>

/* ================= USER SETTINGS ================= */
#define TARGET_RPM   200       // change this to test
#define CPR          4800.0f    // calibrated from your diff data

#define KP           2.0f       // proportional gain
#define KI           0.05f      // integral gain (start small)
#define BASE_PWM     500.0f     // baseline duty so motor spins

/* ================= SIMPLE DELAY ================= */
static void delay(volatile uint32_t t)
{
    while (t--) __NOP();
}

/* ================= UART2 (PA2 / PA3) ================= */

static void uart_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    // PA2, PA3 AF7
    GPIOA->MODER &= ~((3U << (2*2)) | (3U << (3*2)));
    GPIOA->MODER |=  ((2U << (2*2)) | (2U << (3*2)));

    GPIOA->AFR[0] &= ~((0xFU << (2*4)) | (0xFU << (3*4)));
    GPIOA->AFR[0] |=  ((7U  << (2*4)) | (7U  << (3*4)));  // AF7 USART2

    USART2->BRR = 0x008B;  // 115200 @ 16 MHz
    USART2->CR1 = USART_CR1_TE | USART_CR1_UE;
}

static void uart_send(char c)
{
    while (!(USART2->SR & USART_SR_TXE));
    USART2->DR = c;
}

static void uart_print(const char *s)
{
    while (*s) uart_send(*s++);
}

static void uart_print_num(int32_t n)
{
    char buf[16];
    int i = 0;

    if (n == 0) {
        uart_send('0');
        return;
    }
    if (n < 0) {
        uart_send('-');
        n = -n;
    }
    while (n > 0) {
        buf[i++] = (n % 10) + '0';
        n /= 10;
    }
    while (i--) uart_send(buf[i]);
}

/* ================= MOTOR DIR: PB0/PB1 ================= */

static void motor_dir_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;

    GPIOB->MODER &= ~((3U << (0*2)) | (3U << (1*2)));
    GPIOB->MODER |=  ((1U << (0*2)) | (1U << (1*2)));   // outputs
}

static void motor_forward(void)
{
    GPIOB->ODR |=  (1U << 0);   // IN1 HIGH
    GPIOB->ODR &= ~(1U << 1);   // IN2 LOW
}

/* ================= PWM: PA8 (TIM1_CH1) ================= */

static void pwm_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

    GPIOA->MODER &= ~(3U << (8*2));
    GPIOA->MODER |=  (2U << (8*2));         // AF mode
    GPIOA->AFR[1] &= ~(0xFU << 0);
    GPIOA->AFR[1] |=  (1U  << 0);           // AF1 TIM1_CH1

    // TIM1: 1 kHz PWM (16 MHz / (PSC+1) / (ARR+1))
    TIM1->PSC = 15;           // 16MHz / 16 = 1MHz
    TIM1->ARR = 999;          // 1MHz / 1000 = 1kHz

    TIM1->CCMR1 &= ~TIM_CCMR1_OC1M;
    TIM1->CCMR1 |=  (6U << 4);  // PWM mode 1
    TIM1->CCER  |=  TIM_CCER_CC1E;

    TIM1->BDTR |= TIM_BDTR_MOE;
    TIM1->CR1  |= TIM_CR1_CEN;
}

static void set_pwm(uint16_t duty)
{
    if (duty > 999) duty = 999;
    // duty should never be negative because we clamp before calling this
    TIM1->CCR1 = duty;
}

/* ================= ENCODER: TIM2 on PA0/PA1 ================= */

static void encoder_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    GPIOA->MODER &= ~((3U << (0*2)) | (3U << (1*2)));
    GPIOA->MODER |=  ((2U << (0*2)) | (2U << (1*2)));    // AF

    GPIOA->AFR[0] &= ~((0xFU << (0*4)) | (0xFU << (1*4)));
    GPIOA->AFR[0] |=  ((1U  << (0*4)) | (1U  << (1*4))); // AF1 TIM2

    TIM2->SMCR  = 0;
    TIM2->CCMR1 = 0;
    TIM2->CCER  = 0;

    TIM2->SMCR  |= TIM_SMCR_SMS_0 | TIM_SMCR_SMS_1;      // Encoder mode 3
    TIM2->CCMR1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
    TIM2->CCER  |= TIM_CCER_CC1E | TIM_CCER_CC2E;

    TIM2->ARR = 0xFFFF;
    TIM2->CNT = 0;
    TIM2->CR1 |= TIM_CR1_CEN;
}

/* ================= MAIN ================= */

int main(void)
{
    uart_init();
    pwm_init();
    motor_dir_init();
    encoder_init();

    motor_forward();

    uart_print("\r\n=== CLOSED-LOOP RPM TEST (CPR=4800, PI) ===\r\n");

    int32_t last_count = 0;
    float   pwm = BASE_PWM;
    float   integral = 0.0f;       // integral of error
    float   rpm_f = 0.0f;          // optional filtered RPM

    set_pwm((uint16_t)pwm);

    while (1)
    {
        // 100 ms sample window
        delay(1600000);

        int32_t now  = (int32_t)TIM2->CNT;
        int32_t diff = now - last_count;

        // Handle wraparound
        if (diff > 32767)       diff -= 65536;
        else if (diff < -32768) diff += 65536;

        last_count = now;

        // counts per 100ms â†’ rpm = diff * 600 / CPR
        float rpm_inst = (float)diff * 600.0f / CPR;
        if (rpm_inst < 0) rpm_inst = -rpm_inst;   // ignore direction sign

        // optional simple low-pass filter on RPM
        rpm_f = 0.7f * rpm_f + 0.3f * rpm_inst;

        int32_t rpm_print = (int32_t)(rpm_f + 0.5f);

        // ----- PI control -----
        float error = (float)TARGET_RPM - rpm_f;

        // integrate error (dt is constant 0.1s, so we just accumulate)
        integral += error;

        // anti-windup clamp on integral term
        if (integral > 2000.0f)  integral = 2000.0f;
        if (integral < -2000.0f) integral = -2000.0f;

        // PI output
        pwm = BASE_PWM + KP * error + KI * integral;

        // clamp PWM before writing
        if (pwm > 999.0f) pwm = 999.0f;
        if (pwm < 0.0f)   pwm = 0.0f;

        set_pwm((uint16_t)pwm);

        // ----- Debug print -----
        uart_print("RPM: ");
        uart_print_num(rpm_print);
        uart_print("  PWM: ");
        uart_print_num((int32_t)pwm);
        uart_print("\r\n");
    }
}
